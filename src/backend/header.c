static const char *header = "/*\n"
" * Simplified BSD License\n"
" *\n"
" * Copyright (c) 1988-1989, Digital Equipment Corporation & INRIA.\n"
" * Copyright (c) 1992-2020, Eligis\n"
" * All rights reserved.\n"
" *\n"
" * Redistribution and  use in  source and binary  forms, with  or without\n"
" * modification, are permitted provided that the following conditions are\n"
" * met:\n"
" *\n"
" * o Redistributions  of  source  code must  retain  the  above copyright\n"
" *   notice, this list of conditions and the following disclaimer.\n"
" * o Redistributions  in  binary form  must reproduce the above copyright\n"
" *   notice, this list of conditions and  the following disclaimer in the\n"
" *   documentation and/or other materials provided with the distribution.\n"
" * \n"
" * THIS SOFTWARE  IS PROVIDED BY  THE COPYRIGHT HOLDERS  AND CONTRIBUTORS\n"
" * \"AS  IS\" AND  ANY EXPRESS  OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT\n"
" * LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n"
" * A PARTICULAR PURPOSE  ARE DISCLAIMED. IN NO EVENT  SHALL THE COPYRIGHT\n"
" * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n"
" * SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL  DAMAGES (INCLUDING,  BUT  NOT\n"
" * LIMITED TO, PROCUREMENT OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE,\n"
" * DATA, OR PROFITS; OR BUSINESS  INTERRUPTION) HOWEVER CAUSED AND ON ANY\n"
" * THEORY OF  LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY,  OR TORT\n"
" * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  IN ANY WAY OUT OF THE USE\n"
" * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
" */\n"
"\n"
"/**\n"
" * @file bign.h\n"
" * @brief Types and structures for clients of BigN.\n"
" * Bignum internal representation\n"
" * ~~~{.unparsed}\n"
" *  <--------------------------- nl ---------------------------->\n"
" *  |   Least                                           Most    |\n"
" *  |Significant|           |           |           |Significant|\n"
" *  |BigNumDigit|           |           |           |BigNumDigit|\n"
" *  |___________|___________|___________|___________|___________|\n"
" *        ^                                          (sometimes\n"
" *        |                                            is zero)\n"
" *       nn\n"
" * ~~~\n"
" * @version 2.0.0\n"
" * @copyright Digital Equipment Corporation & INRIA, 1988-1989.\n"
" * @copyright Eligis, 1992-2020\n"
" * @authors B. Serpette\n"
" * @authors J. Vuillemin\n"
" * @authors J.C. Herv&eacute;\n"
" * @authors C. Jullien\n"
" * $Revision: 1.54 $\n"
" * $Date: 2019/12/21 08:22:54 $\n"
" */\n"
"\n"
"#if !defined(__BIGN_H)\n"
"#define __BIGN_H\n"
"\n"
"#if defined(HAVE_CONFIG_H)\n"
"#include \"config.h\"\n"
"#endif\n"
"\n"
"#if defined(_WIN64) || defined(HAVE_STDINT_H)\n"
"#include <stdint.h>\n"
"#endif\n"
"\n"
"#if defined(__cplusplus)\n"
"extern  \"C\"     {\n"
"#endif\n"
"\n"
"/** @cond */\n"
"#if defined(BN_EXPERIMENTAL_128BIT)\n"
"#define BN_NUM_DIGIT_TYPE\n"
"typedef __uint128_t             BigNumDigit;\n"
"#endif\n"
"\n"
"/*\n"
" *      Internal digit type.\n"
" */\n"
"\n"
"#if !defined(BN_NUM_DIGIT_TYPE)\n"
"#define BN_NUM_DIGIT_TYPE\n"
"#if defined(_WIN64) || ( defined(HAVE_STDINT_H) && (SIZEOF_VOID_P >= 8))\n"
"typedef uint64_t                BigNumDigit;\n"
"#else\n"
"typedef unsigned long           BigNumDigit;\n"
"#endif\n"
"#endif\n"
"\n"
"#if defined(__GNUC__) && (__GNUC__ >= 3)\n"
"#if !defined(BN_CONST_FUNCTION)\n"
"#define BN_CONST_FUNCTION       __attribute__((const))\n"
"#endif\n"
"#if !defined(BN_PURE_FUNCTION)\n"
"#define BN_PURE_FUNCTION        __attribute__((pure))\n"
"#endif\n"
"#endif  /* __GNUC__ >= 3 */\n"
"\n"
"#if !defined(BN_PURE_FUNCTION)\n"
"#define BN_PURE_FUNCTION\n"
"#endif\n"
"\n"
"#if !defined(BN_CONST_FUNCTION)\n"
"#define BN_CONST_FUNCTION\n"
"#endif\n"
"\n"
"/*\n"
" *      bignum types: digits, big numbers, carries ...\n"
" */\n"
"\n"
"typedef BigNumDigit *   BigNum;         /* A big number is a digit pointer */\n"
"typedef BigNumDigit     BigNumProduct;  /* The product of two digits       */\n"
"#if defined(BN_EXPERIMENTAL_128BITX)\n"
"typedef __uint128_t     BigNumLength;   /* The length of a bignum          */\n"
"#else\n"
"typedef unsigned int    BigNumLength;   /* The length of a bignum          */\n"
"#endif\n"
"/** @endcond */\n"
"\n"
"/**\n"
" * BigNum boolean enum.\n"
" */\n"
"typedef enum {\n"
"        /** false value (0). */\n"
"        BN_FALSE   = 0,\n"
"        /** true value (1). */\n"
"        BN_TRUE    = 1\n"
"} BigNumBool;\n"
"\n"
"/**\n"
" * Results of compare functions.\n"
" */\n"
"typedef enum {\n"
"        /** Less than value (-1). */\n"
"        BN_LT      = -1,\n"
"        /** Equal than == value (0). */\n"
"        BN_EQ      = 0,\n"
"        /** Greater than comparison value (1). */\n"
"        BN_GT      = 1\n"
"} BigNumCmp;\n"
"\n"
"/**\n"
" * Carry pseudo-boolean enum type.\n"
" */\n"
"typedef enum {\n"
"        /** No carry (0). */\n"
"        BN_NOCARRY = 0,\n"
"        /** Carry (1). */\n"
"        BN_CARRY   = 1\n"
"} BigNumCarry;\n"
"\n"
"/*\n"
" *      sizes\n"
" *\n"
" *      BN_BYTE_SIZE:   number of bits in a byte\n"
" *      BN_DIGIT_SIZE:  number of bits in a digit of a BigNum\n"
" */\n"
"\n"
"#if !defined(BN_BYTE_SIZE)\n"
"/**\n"
" * A byte size is generally 8 on most modern machines\n"
" * but may be 9! on old 36bit computers.\n"
" */\n"
"#define BN_BYTE_SIZE    ((BigNumLength)8)\n"
"#endif\n"
"\n"
"/**\n"
" * Digit size.\n"
" */\n"
"#define BN_DIGIT_SIZE   (sizeof(BigNumDigit) * BN_BYTE_SIZE)\n"
"\n"
"/*\n"
" * some constants\n"
" */\n"
"\n"
"/**\n"
" * Digit ZERO constant (0)\n"
" */\n"
"#define BN_ZERO         ((BigNumDigit)0)\n"
"/**\n"
" * Digit ONE constant (1).\n"
" */\n"
"#define BN_ONE          ((BigNumDigit)1)\n"
"/**\n"
" * Digit COMPLEMENT constant (~0)\n"
" */\n"
"#define BN_COMPLEMENT   (~(BigNumDigit)0)\n"
"\n"
"/*\n"
" *      functions of bign.c\n"
" */\n"
"\n"
"extern BigNumCarry  BnnAdd(BigNum mm, BigNumLength ml, const BigNum nn, BigNumLength nl, BigNumCarry carryin);\n"
"extern BigNumCarry  BnnAddCarry(BigNum nn, BigNumLength nl, BigNumCarry carryin);\n"
"extern void         BnnAndDigits(BigNum n, BigNumDigit d);\n"
"extern void         BnnAssign(BigNum mm, const BigNum nn, BigNumLength nl);\n"
"extern BigNumCmp    BnnCompare(const BigNum mm, BigNumLength ml, const BigNum nn, BigNumLength nl) BN_PURE_FUNCTION;\n"
"extern BigNumCmp    BnnCompareDigits(BigNumDigit d1, BigNumDigit d2) BN_CONST_FUNCTION;\n"
"extern void         BnnComplement(BigNum nn, BigNumLength nl);\n"
"extern void         BnnComplement2(BigNum nn, BigNumLength nl);\n"
"extern void         BnnDivide(BigNum nn, BigNumLength nl, BigNum dd, BigNumLength dl);\n"
"extern BigNumDigit  BnnDivideDigit(BigNum qq, BigNum nn, BigNumLength nl, BigNumDigit d);\n"
"extern BigNumDigit  BnnGetDigit(const BigNum nn) BN_PURE_FUNCTION;\n"
"extern BigNumBool   BnnIsPower2(const BigNum nn, BigNumLength nl) BN_PURE_FUNCTION;\n"
"extern BigNumBool   BnnIsDigitEven(BigNumDigit d) BN_CONST_FUNCTION;\n"
"extern BigNumBool   BnnIsDigitOdd(BigNumDigit d) BN_CONST_FUNCTION;\n"
"extern BigNumBool   BnnIsDigitNormalized(BigNumDigit d) BN_CONST_FUNCTION;\n"
"extern BigNumBool   BnnIsDigitZero(BigNumDigit d) BN_CONST_FUNCTION;\n"
"extern BigNumBool   BnnIsZero(const BigNum nn, BigNumLength nl) BN_PURE_FUNCTION;\n"
"extern BigNumCarry  BnnMultiply(BigNum pp, BigNumLength pl, const BigNum mm, BigNumLength ml, const BigNum nn, BigNumLength nl);\n"
"extern BigNumCarry  BnnMultiplyDigit(BigNum pp, BigNumLength pl, const BigNum mm, BigNumLength ml, BigNumDigit d);\n"
"extern BigNumLength BnnNumDigits(const BigNum nn, BigNumLength nl) BN_PURE_FUNCTION;\n"
"extern BigNumLength BnnNumLength(const BigNum nn, BigNumLength nl) BN_PURE_FUNCTION;\n"
"extern BigNumLength BnnNumCount(const BigNum nn, BigNumLength nl) BN_PURE_FUNCTION;\n"
"extern BigNumLength BnnNumLeadingZeroBitsInDigit(BigNumDigit d) BN_CONST_FUNCTION;\n"
"extern void         BnnOrDigits(BigNum n, BigNumDigit d);\n"
"extern void         BnnSetDigit(BigNum nn, BigNumDigit d);\n"
"extern void         BnnSetToZero(BigNum nn, BigNumLength nl);\n"
"extern BigNumDigit  BnnShiftLeft(BigNum mm, BigNumLength ml, BigNumLength nbits);\n"
"extern BigNumDigit  BnnShiftRight(BigNum mm, BigNumLength ml, BigNumLength nbits);\n"
"extern BigNumCarry  BnnSubtract(BigNum mm, BigNumLength ml, const BigNum nn, BigNumLength nl, BigNumCarry carryin);\n"
"extern BigNumCarry  BnnSubtractBorrow(BigNum nn, BigNumLength nl, BigNumCarry carryin);\n"
"extern void         BnnXorDigits(BigNum n, BigNumDigit d);\n"
"\n"
"#if defined(__cplusplus)\n"
"}\n"
"#endif\n"
"\n"
"#endif  /* __BIGN_H */\n"
"/*\n"
" * Simplified BSD License\n"
" *\n"
" * Copyright (c) 1988-1989, Digital Equipment Corporation & INRIA.\n"
" * Copyright (c) 1992-2020, Eligis\n"
" * All rights reserved.\n"
" *\n"
" * Redistribution and  use in  source and binary  forms, with  or without\n"
" * modification, are permitted provided that the following conditions are\n"
" * met:\n"
" *\n"
" * o Redistributions  of  source  code must  retain  the  above copyright\n"
" *   notice, this list of conditions and the following disclaimer.\n"
" * o Redistributions  in  binary form  must reproduce the above copyright\n"
" *   notice, this list of conditions and  the following disclaimer in the\n"
" *   documentation and/or other materials provided with the distribution.\n"
" *\n"
" * THIS SOFTWARE  IS PROVIDED BY  THE COPYRIGHT HOLDERS  AND CONTRIBUTORS\n"
" * \"AS  IS\" AND  ANY EXPRESS  OR IMPLIED  WARRANTIES, INCLUDING,  BUT NOT\n"
" * LIMITED TO, THE IMPLIED  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n"
" * A PARTICULAR PURPOSE  ARE DISCLAIMED. IN NO EVENT  SHALL THE COPYRIGHT\n"
" * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n"
" * SPECIAL,  EXEMPLARY,  OR  CONSEQUENTIAL  DAMAGES (INCLUDING,  BUT  NOT\n"
" * LIMITED TO, PROCUREMENT OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE,\n"
" * DATA, OR PROFITS; OR BUSINESS  INTERRUPTION) HOWEVER CAUSED AND ON ANY\n"
" * THEORY OF  LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY,  OR TORT\n"
" * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  IN ANY WAY OUT OF THE USE\n"
" * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
" */\n"
"\n"
"/**\n"
" * @file bigz.h\n"
" * @brief Types and structures for clients of BigZ.\n"
" * @version 2.0.0\n"
" * @copyright Digital Equipment Corporation & INRIA, 1988-1989.\n"
" * @copyright Eligis, 1992-2020\n"
" * @authors B. Serpette\n"
" * @authors J. Vuillemin\n"
" * @authors J.C. Herv&eacute;\n"
" * @authors C. Jullien\n"
" * $Revision: 1.116 $\n"
" * $Date: 2019/12/21 08:22:55 $\n"
" */\n"
"\n"
"#if !defined(__BIGZ_H)\n"
"#define __BIGZ_H\n"
"\n"
"#if !defined(__BIGN_H)\n"
"#include \"bign.h\"\n"
"#endif\n"
"\n"
"#if defined(__cplusplus)\n"
"extern  \"C\"     {\n"
"#endif\n"
"\n"
"#include <stddef.h>\n"
"#include <stdint.h>\n"
"#ifndef NULL\n"
"#define NULL ((void*)0)\n"
"#endif\n"
"void *malloc(size_t);\n"
"\n"
"/** @cond */\n"
"#define BZ_PURE_FUNCTION                BN_PURE_FUNCTION\n"
"#define BZ_CONST_FUNCTION               BN_CONST_FUNCTION\n"
"/** @endcond */\n"
"\n"
"/**\n"
" * BigZ version MM.mm.pp.\n"
" */\n"
"#define BZ_VERSION                      \"2.0.0\"\n"
"\n"
"/**\n"
" * BigZ sign\n"
" */\n"
"typedef enum {\n"
"        /** Negative */\n"
"        BZ_MINUS = -1,\n"
"        /** Zero */\n"
"        BZ_ZERO  = 0,\n"
"        /** Positive */\n"
"        BZ_PLUS  = 1\n"
"} BzSign;\n"
"\n"
"/**\n"
" * BigZ compare result\n"
" */\n"
"typedef enum {\n"
"        /** Less than value (-1). */\n"
"        BZ_LT    = BN_LT,\n"
"        /** Equal than == value (0). */\n"
"        BZ_EQ    = BN_EQ,\n"
"        /** Greater than comparison value (1). */\n"
"        BZ_GT    = BN_GT\n"
"} BzCmp;\n"
"\n"
"/** @cond */\n"
"typedef enum {\n"
"        BZ_UNTIL_END     = 0,\n"
"        BZ_UNTIL_INVALID = 1,\n"
"        BZ_UNTIL_SLASH   = 2,\n"
"        BZ_UNTIL_SPACE   = 3\n"
"} BzStrFlag;\n"
"\n"
"/**\n"
" * BigZ number header.\n"
" */\n"
"typedef struct {\n"
"        BigNumLength    Size;\n"
"        BzSign          Sign;\n"
"} BigZHeader;\n"
"\n"
"/*\n"
" * define a dummy positive value to declare a Digits vector.\n"
" * BigZ is allocated with required size. Choose a rather large value\n"
" * to prevent 'smart' compilers to exchange fields.\n"
" */\n"
"\n"
"#define BZ_DUMMY_SIZE   32\n"
"\n"
"typedef struct {\n"
"        BigZHeader Header;\n"
"        /*\n"
"         * Digit vector should be the last field to allow allocation\n"
"         * of the real size (BZ_DUMMY_SIZE is never used).\n"
"         */\n"
"        BigNumDigit Digits[BZ_DUMMY_SIZE];\n"
"} BigZStruct;\n"
"\n"
"typedef BigZStruct *                    __BigZ;\n"
"typedef const BigZStruct *              __CBigZ;\n"
"\n"
"/**\n"
" * BzToString and related functions add sign only when number is negative ('-').\n"
" */\n"
"#define BZ_DEFAULT_SIGN                 0\n"
"\n"
"/**\n"
" * Force BzToString and related functions to always add a sign [+|-] when\n"
" * number is not 0.\n"
" */\n"
"#define BZ_FORCE_SIGN                   1\n"
"\n"
"/*\n"
" * macros of bigz.c\n"
" */\n"
"\n"
"#if !defined(BZ_BIGNUM_TYPE)\n"
"#define BZ_BIGNUM_TYPE\n"
"typedef __BigZ                          BigZ;\n"
"typedef __CBigZ                         CBigZ;\n"
"#endif\n"
"\n"
"#if !defined(BZ_CHAR_TYPE)\n"
"#define BZ_CHAR_TYPE\n"
"typedef char                            BzChar;\n"
"#endif\n"
"\n"
"#if defined(BZ_EXPERIMENTAL_128BIT)\n"
"/*\n"
" * No really need to use those types. The most important thing to have is\n"
" * bucket size of 128bit as provided by BN_EXPERIMENTAL_128BIT.\n"
" */\n"
"#define BZ_INT_TYPE\n"
"typedef __int128_t                      BzInt;\n"
"#define BZ_UINT_TYPE\n"
"typedef __uint128_t                     BzUInt;\n"
"#endif\n"
"\n"
"\n"
"#if !defined(BZ_INT_TYPE)\n"
"#define BZ_INT_TYPE\n"
"#if defined(_WIN64) || ( defined(HAVE_STDINT_H) && (SIZEOF_VOID_P >= 8))\n"
"typedef int64_t                         BzInt;\n"
"#else\n"
"typedef int                             BzInt;\n"
"#endif\n"
"#endif\n"
"\n"
"#if !defined(BZ_UINT_TYPE)\n"
"#define BZ_UINT_TYPE\n"
"#if defined(_WIN64) || ( defined(HAVE_STDINT_H) && (SIZEOF_VOID_P >= 8))\n"
"typedef uint64_t                        BzUInt;\n"
"#else\n"
"typedef unsigned int                    BzUInt;\n"
"#endif\n"
"#endif\n"
"\n"
"/*\n"
" * Random seed type, by contract it must be an unsigned int.\n"
" */\n"
"typedef unsigned int                    BzSeed;\n"
"\n"
"#define BZ_OPTIMIZE_PRINT\n"
"\n"
"#if !defined(BZ_BUCKET_SIZE)\n"
"#if defined(_WIN64) || ( defined(SIZEOF_LONG) && (SIZEOF_LONG == 8))\n"
"#define BZ_BUCKET_SIZE 64\n"
"#else\n"
"#define BZ_BUCKET_SIZE 32\n"
"#endif\n"
"#endif\n"
"/** @endcond */\n"
"\n"
"#if !defined(__EXTERNAL_BIGZ_MEMORY)\n"
"/**\n"
" * User overloadable macro that gets native BigZ implementation from\n"
" * a high level object (for example managed in C++ or Lisp).\n"
" */\n"
"#define __toBzObj(z)                    ((__BigZ)z)\n"
"/**\n"
" * NULL BigZ.\n"
" */\n"
"#define BZNULL                          ((BigZ)0)\n"
"/**\n"
" * User overloadable macro called to allocate size bytes to store a BigZ.\n"
" */\n"
"#define BzAlloc(size)                   malloc(size)\n"
"// #define BzAlloc(size)                   bzalloc(size)\n"
"// extern void *bzalloc(size_t size);\n"
"/**\n"
" * User overloadable macro called to free a BigZ allocated by BzAlloc.\n"
" */\n"
"#define BzFree(z)                       free(z)\n"
"// #define BzFree(z)                       bzfree(z)\n"
"// extern void bzfree(void *p);\n"
"/**\n"
" * User overloadable macro called to allocate size BzChar that represent\n"
" * a BzString.\n"
" */\n"
"#define BzStringAlloc(size)             malloc(size * sizeof(BzChar))\n"
"/**\n"
" * User overloadable macro called to free a buffer allocated by BzStringAlloc.\n"
" */\n"
"#define BzFreeString(s)                 free(s)\n"
"#endif\n"
"\n"
"/** @cond */\n"
"#define BzGetSize(z)                    (__toBzObj(z)->Header.Size)\n"
"#define BzGetSign(z)                    (__toBzObj(z)->Header.Sign)\n"
"#define BzGetDigit(z,n)                 (__toBzObj(z)->Digits[n])\n"
"#define BzToBn(z)                       (__toBzObj(z)->Digits)\n"
"#define BzSetSize(z, s)                 (__toBzObj(z)->Header.Size = (s))\n"
"#define BzSetSign(z, s)                 (__toBzObj(z)->Header.Sign = (s))\n"
"#define BzSetDigit(z, n, v)             (__toBzObj(z)->Digits[n]   = (v))\n"
"/** @endcond */\n"
"\n"
"/*\n"
" *      functions of bigz.c\n"
" */\n"
"\n"
"extern const char * BzVersion(void) BZ_CONST_FUNCTION;\n"
"extern BigZ         BzCreate(BigNumLength Size);\n"
"extern BigNumLength BzNumDigits(const BigZ z) BZ_PURE_FUNCTION;\n"
"extern BigNumLength BzLength(const BigZ z) BZ_PURE_FUNCTION;\n"
"extern BigZ         BzCopy(const BigZ z);\n"
"extern BigZ         BzNegate(const BigZ z);\n"
"extern BigZ         BzAbs(const BigZ z);\n"
"extern BzCmp        BzCompare(const BigZ y, const BigZ z) BZ_PURE_FUNCTION;\n"
"extern BigZ         BzAdd(const BigZ y, const BigZ z);\n"
"extern BigZ         BzSubtract(const BigZ y, const BigZ z);\n"
"extern BigZ         BzMultiply(const BigZ y, const BigZ z);\n"
"extern BigZ         BzDivide(const BigZ y, const BigZ z, BigZ *r);\n"
"extern BigZ         BzDiv(const BigZ y, const BigZ z);\n"
"extern BigZ         BzTruncate(const BigZ y, const BigZ z);\n"
"extern BigZ         BzFloor(const BigZ y, const BigZ z);\n"
"extern BigZ         BzCeiling(const BigZ y, const BigZ z);\n"
"extern BigZ         BzRound(const BigZ y, const BigZ z);\n"
"extern BigZ         BzMod(const BigZ y, const BigZ z);\n"
"extern BigZ         BzRem(const BigZ y, const BigZ z);\n"
"extern BigZ         BzPow(const BigZ base, BzUInt exponent);\n"
"extern BigNumBool   BzIsEven(const BigZ y) BZ_PURE_FUNCTION;\n"
"extern BigNumBool   BzIsOdd(const BigZ y) BZ_PURE_FUNCTION;\n"
"extern BzChar *     BzToString(const BigZ z, BigNumDigit base, int sign);\n"
"extern size_t       BzStrLen(const BzChar *s) BN_PURE_FUNCTION;\n"
"extern BzChar *     BzToStringBuffer(const BigZ z, BigNumDigit base, int sign, /*@null@*/ BzChar * const buf, /*@null@*/ size_t *len);\n"
"extern BzChar *     BzToStringBufferExt(const BigZ z, BigNumDigit base, int sign, /*@null@*/ BzChar * const buf, /*@null@*/ size_t *len, /*@null@*/ size_t *slen);\n"
"extern BigZ         BzFromStringLen(const BzChar *s, size_t len, BigNumDigit base, BzStrFlag flag);\n"
"extern BigZ         BzFromString(const BzChar *s, BigNumDigit base, BzStrFlag flag);\n"
"extern BigZ         BzFromInteger(BzInt i);\n"
"extern BigZ         BzFromUnsignedInteger(BzUInt i);\n"
"extern BzInt        BzToInteger(const BigZ z) BZ_PURE_FUNCTION;\n"
"extern double       BzToDouble(const BigZ z) BZ_PURE_FUNCTION;\n"
"extern int          BzToIntegerPointer(const BigZ z, BzInt *p);\n"
"extern BzUInt       BzToUnsignedInteger(const BigZ z) BZ_PURE_FUNCTION;\n"
"extern int          BzToUnsignedIntegerPointer(const BigZ z, BzUInt *p);\n"
"extern BigZ         BzFromBigNum(const BigNum n, BigNumLength nl);\n"
"extern BigNum       BzToBigNum(const BigZ z, BigNumLength *nl);\n"
"extern BigNumBool   BzTestBit(BigNumLength bit, const BigZ z);\n"
"extern BigNumLength BzBitCount(const BigZ z);\n"
"extern BigZ         BzNot(const BigZ z);\n"
"extern BigZ         BzAnd(const BigZ y, const BigZ z);\n"
"extern BigZ         BzOr(const BigZ y, const BigZ z);\n"
"extern BigZ         BzXor(const BigZ y, const BigZ z);\n"
"extern BigZ         BzNand(const BigZ x, const BigZ y);\n"
"extern BigZ         BzNor(const BigZ x, const BigZ y);\n"
"extern BigZ         BzEqv(const BigZ x, const BigZ y);\n"
"extern BigZ         BzAndC1(const BigZ x, const BigZ y);\n"
"extern BigZ         BzAndC2(const BigZ x, const BigZ y);\n"
"extern BigZ         BzOrC1(const BigZ x, const BigZ y);\n"
"extern BigZ         BzOrC2(const BigZ x, const BigZ y);\n"
"extern BigZ         BzAsh(const BigZ y, int n);\n"
"extern BigZ         BzSqrt(const BigZ z);\n"
"extern BigZ         BzLcm(const BigZ y, const BigZ z);\n"
"extern BigZ         BzGcd(const BigZ y, const BigZ z);\n"
"extern BigZ         BzRandom(const BigZ n, BzSeed *seed);\n"
"extern BigZ         BzModExp(const BigZ base, const BigZ exponent, const BigZ modulus);\n"
"\n"
"/*\n"
"#define BZ_DEBUG\n"
"*/\n"
"\n"
"#if defined(BZ_DEBUG)\n"
"extern void         BnDebug(const char *m, const BzChar *bzstr, const BigNum n, BigNumLength nl, BzSign sign);\n"
"extern void         BzDebug(const char *m, const BigZ y);\n"
"#endif\n"
"\n"
"#if defined(__cplusplus)\n"
"}\n"
"#endif\n"
"\n"
"#endif  /* __BIGZ_H */\n"
"#ifndef KILITE_TEMPLATE_HEADER_H\n"
"#define KILITE_TEMPLATE_HEADER_H\n"
"\n"
"#include <stdint.h>\n"
"#include <stddef.h>\n"
"#include <stdarg.h>\n"
"\n"
"extern BigZ i64maxp1;\n"
"extern BigZ i64minm1;\n"
"\n"
"// printf(\"%s:%d -> %s\\n\", __FILE__, __LINE__, __func__);\n"
"\n"
"#ifndef __MIRC__\n"
"#define INLINE\n"
"#include <stdio.h>\n"
"#include <stdlib.h>\n"
"#include <string.h>\n"
"#else\n"
"#define INLINE inline\n"
"int printf(const char *, ...);\n"
"#ifdef WIN32\n"
"int _snprintf(char *, int, const char *, ...);\n"
"#define snprintf _snprintf\n"
"#else\n"
"int snprintf(char *, int, const char *, ...);\n"
"#endif\n"
"int64_t strtoll(const char*, char**, int);\n"
"void *malloc(size_t);\n"
"void *calloc(size_t, size_t);\n"
"void *memset(void *, int, size_t);\n"
"void free(void *);\n"
"char *strcpy(char *s1, const char *s2);\n"
"int strcmp(const char *s1, const char *s2);\n"
"#define NULL ((void*)0)\n"
"#endif\n"
"\n"
"#define FRM_STACK_SIZE (1024)\n"
"#define VAR_STACK_SIZE (1024*16)\n"
"#define ALC_UNIT (1024)\n"
"#define ALC_UNIT_FRM (1024)\n"
"#define TICK_UNIT (1024*64)\n"
"#define STR_UNIT (32)\n"
"#define HASH_SIZE (23)\n"
"#define HASHITEM_EMPTY(h) ((h)->hasht = 0x00)\n"
"#define HASHITEM_EXIST(h) ((h)->hasht = 0x01)\n"
"#define HASHITEM_REMVD(h) ((h)->hasht = 0x02)\n"
"#define IS_HASHITEM_EMPTY(h) ((h)->hasht == 0x00)\n"
"#define IS_HASHITEM_EXIST(h) ((h)->hasht == 0x01)\n"
"#define IS_HASHITEM_REMVD(h) ((h)->hasht == 0x02)\n"
"#define VARS_MIN_IN_FRAME (32)\n"
"#define GC_CHECK(ctx) do { if (--((ctx)->tick) == 0) mark_and_sweep(ctx); } while(0)\n"
"\n"
"#define MARK(obj) ((obj)->flags |= 0x01)\n"
"#define HOLD(obj) ((obj)->flags |= 0x02)\n"
"#define UNMARK(obj) ((obj)->flags &= 0xFE)\n"
"#define UNHOLD(obj) ((obj)->flags &= 0xFD)\n"
"#define IS_MARKED(obj) (((obj)->flags & 0x01) == 0x01)\n"
"#define IS_HELD(obj) (((obj)->flags & 0x02) == 0x02)\n"
"\n"
"#define push_frm(ctx, m) do { if ((ctx)->fstksz <= (ctx)->fstkp) { /* TODO: stack overflow */ } (((ctx)->fstk)[((ctx)->fstkp)++] = (m)); } while (0)\n"
"#define pop_frm(ctx) (--((ctx)->fstkp))\n"
"\n"
"#define alloc_var(ctx, n) do { if ((ctx)->vstksz <= ((ctx)->vstkp + n)) { /* TODO: stack overflow */ } (((ctx)->vstkp) += (n)); } while (0)\n"
"#define vstackp(ctx) ((ctx)->vstkp)\n"
"#define push_var(ctx, v) do { if ((ctx)->vstksz <= (ctx)->vstkp) { /* TODO: stack overflow */ } (((ctx)->vstk)[((ctx)->vstkp)++].a = (v)); } while (0)\n"
"#define pop_var(ctx) (--((ctx)->vstkp))\n"
"#define top_var(ctx) (((ctx)->vstk)[((ctx)->vstkp) - 1].a)\n"
"#define arg_var(ctx, n) (((ctx)->vstk)[(ctx)->vstkp - ((n) + 1)].a)\n"
"#define reduce_vstackp(ctx, n) (((ctx)->vstkp) -= (n))\n"
"#define restore_vstackp(ctx, p) (((ctx)->vstkp) = (p))\n"
"#define init_var(v) ((v)->t = VAR_INT64, (v)->i = 0)\n"
"#define local_var(ctx, n) (&(((ctx)->vstk)[(ctx)->vstkp - ((n) + 1)]))\n"
"#define local_var_index(n) ((ctx)->vstkp - ((n) + 1))\n"
"#define fram_var(frm, n) (frm->v[n])\n"
"\n"
"/***************************************************************************\n"
" * VM Variable\n"
"*/\n"
"\n"
"#define IS_VMINT(x) ((x) <= VAR_BIG)\n"
"typedef enum vartype {\n"
"    VAR_INT64 = 0x00,\n"
"    VAR_BIG,\n"
"    VAR_DBL,\n"
"    VAR_STR,\n"
"    VAR_FNC,\n"
"    VAR_OBJ,\n"
"} vartype;\n"
"\n"
"struct vmctx;\n"
"struct vmvar;\n"
"struct vmfnc;\n"
"struct vmfrm;\n"
"\n"
"typedef struct vmbgi {\n"
"    struct vmbgi *prv;  /* The link to the previous item in alive list. */\n"
"    struct vmbgi *liv;  /* The link to the next item in alive list. */\n"
"    struct vmbgi *nxt;  /* The link to the next item in free list. */\n"
"    struct vmbgi *chn;  /* The link in allocated object list */\n"
"\n"
"    int32_t flags;\n"
"    BigZ b;\n"
"} vmbgi;\n"
"\n"
"typedef struct vmstr {\n"
"    struct vmstr *prv;  /* The link to the previous item in alive list. */\n"
"    struct vmstr *liv;  /* The link to the next item in alive list. */\n"
"    struct vmstr *nxt;  /* The link to the next item in free list. */\n"
"    struct vmstr *chn;  /* The link in allocated object list */\n"
"\n"
"    int32_t flags;\n"
"    int cap;\n"
"    int len;\n"
"    char *s;\n"
"    char *hd;\n"
"} vmstr;\n"
"\n"
"typedef struct vmhsh {\n"
"    struct vmhsh *prv;  /* The link to the previous item in alive list. */\n"
"    struct vmhsh *liv;  /* The link to the next item in alive list. */\n"
"    struct vmhsh *nxt;  /* The link to the next item in free list. */\n"
"    struct vmhsh *chn;  /* The link in allocated object list */\n"
"\n"
"    int32_t flags;\n"
"    int32_t sz;\n"
"    struct vmvar *map;\n"
"} vmhsh;\n"
"\n"
"typedef struct vmvar {\n"
"    struct vmvar *prv;  /* The link to the previous item in alive list. */\n"
"    struct vmvar *liv;  /* The link to the next item in alive list. */\n"
"    struct vmvar *nxt;  /* The link to the next item in free list. */\n"
"    struct vmvar *chn;  /* The link in allocated object list */\n"
"\n"
"    int32_t flags;\n"
"    int32_t hasht;\n"
"    vartype t;\n"
"    int64_t i;\n"
"    double d;\n"
"    vmbgi *bi;\n"
"    vmstr *s;\n"
"    vmhsh *h;           /* The hashmap from string to object */\n"
"    struct vmfnc *f;\n"
"    struct vmvar *a;    /* an object */\n"
"} vmvar;\n"
"\n"
"typedef int (*vmfunc_t)(struct vmctx *ctx, struct vmfrm *lex, struct vmvar **r, int ac);\n"
"typedef struct vmfnc {\n"
"    struct vmfnc *prv;  /* The link to the previous item in alive list. */\n"
"    struct vmfnc *liv;  /* The link to the next item in alive list. */\n"
"    struct vmfnc *nxt;  /* The link to the next item in free list. */\n"
"    struct vmfnc *chn;  /* The link in allocated object list */\n"
"\n"
"    int32_t flags;\n"
"    int32_t args;\n"
"    vmfunc_t f;         /* function prototype have to be fixed */\n"
"    struct vmfrm *frm;  /* the funtion frame holding arguments */\n"
"    struct vmfrm *lex;  /* the lexical frame bound with this function */\n"
"} vmfnc;\n"
"\n"
"typedef struct vmfrm {\n"
"    struct vmfrm *prv;  /* The link to the previous item in alive list. */\n"
"    struct vmfrm *liv;  /* The link to the next item in alive list. */\n"
"    struct vmfrm *nxt;  /* The link to the next item in free list. */\n"
"    struct vmfrm *chn;  /* The link in allocated object list */\n"
"\n"
"    int32_t flags;\n"
"    int32_t vars;\n"
"    struct vmvar **v;\n"
"    struct vmfrm *lex;  /* chain to a lexical frame */\n"
"} vmfrm;\n"
"\n"
"/***************************************************************************\n"
" * VM Context\n"
"*/\n"
"typedef struct vmctx {\n"
"    int tick;\n"
"    int sweep;\n"
"    int gccnt;\n"
"\n"
"    int vstksz;\n"
"    int vstkp;\n"
"    vmvar *vstk;\n"
"\n"
"    int fstksz;\n"
"    int fstkp;\n"
"    vmfrm **fstk;\n"
"\n"
"    vmvar *except;  /* Current exception that was thrown. */\n"
"\n"
"    struct {\n"
"        vmvar var;\n"
"        vmfnc fnc;\n"
"        vmfrm frm;\n"
"        vmstr str;\n"
"        vmbgi bgi;\n"
"        vmhsh hsh;\n"
"    } alc;\n"
"    struct {\n"
"        int var;\n"
"        int fnc;\n"
"        int frm;\n"
"        int str;\n"
"        int bgi;\n"
"        int hsh;\n"
"    } cnt;\n"
"    struct {\n"
"        int var;\n"
"        int fnc;\n"
"        int frm;\n"
"        int str;\n"
"        int bgi;\n"
"        int hsh;\n"
"    } fre;\n"
"} vmctx;\n"
"\n"
"INLINE vmctx *initialize(void);\n"
"INLINE void finalize(vmctx *ctx);\n"
"\n"
"INLINE vmfnc *alcfnc(vmctx *ctx, void *f, vmfrm *lex, int args);\n"
"INLINE void pbakfnc(vmctx *ctx, vmfnc *p);\n"
"INLINE vmfrm *alcfrm(vmctx *ctx, int args);\n"
"INLINE void pbakfrm(vmctx *ctx, vmfrm *p);\n"
"INLINE vmstr *alcstr_str(vmctx *ctx, const char *s);\n"
"INLINE void pbakstr(vmctx *ctx, vmstr *p);\n"
"INLINE vmbgi *alcbgi_bigz(vmctx *ctx, BigZ bz);\n"
"INLINE void pbakbgi(vmctx *ctx, vmbgi *p);\n"
"INLINE vmhsh *alchsh(vmctx *ctx);\n"
"INLINE void pbakhsh(vmctx *ctx, vmhsh *p);\n"
"INLINE vmvar *alcvar(vmctx *ctx, vartype t, int hold);\n"
"INLINE vmvar *alcvar_fnc(vmctx *ctx, vmfnc *f);\n"
"INLINE vmvar *alcvar_int64(vmctx *ctx, int64_t i, int hold);\n"
"INLINE vmvar *alcvar_str(vmctx *ctx, const char *s);\n"
"INLINE vmvar *alcvar_bgistr(vmctx *ctx, const char *s, int radix);\n"
"INLINE void pbakvar(vmctx *ctx, vmvar *p);\n"
"INLINE vmvar *copy_var(vmctx *ctx, vmvar *src, int hold);\n"
"INLINE void copy_var_to(vmctx *ctx, vmvar *dst, vmvar *src);\n"
"\n"
"INLINE void initialize_allocators(vmctx *ctx);\n"
"INLINE void mark_and_sweep(vmctx *ctx);\n"
"INLINE void count(vmctx *ctx);\n"
"\n"
"INLINE void bi_initialize(void);\n"
"INLINE void bi_finalize(void);\n"
"INLINE vmbgi *bi_copy(vmctx *ctx, vmbgi *src);\n"
"INLINE void bi_print(vmbgi *b);\n"
"INLINE void bi_str(char *buf, int max, vmbgi *b);\n"
"\n"
"INLINE vmstr *str_dup(vmctx *ctx, vmstr *vs);\n"
"INLINE vmstr *str_append(vmctx *ctx, vmstr *vs, const char *s, int len);\n"
"INLINE vmstr *str_append_cp(vmctx *ctx, vmstr *vs, const char *s);\n"
"INLINE vmstr *str_append_str(vmctx *ctx, vmstr *vs, vmstr *s2);\n"
"INLINE vmstr *str_ltrim(vmctx *ctx, vmstr *vs, const char *ch);\n"
"INLINE vmstr *str_rtrim(vmctx *ctx, vmstr *vs, const char *ch);\n"
"\n"
"INLINE void hashmap_print(vmhsh *hsh);\n"
"INLINE vmhsh *hashmap_create(vmhsh *h, int sz);\n"
"INLINE vmhsh *hashmap_set(vmctx *ctx, vmhsh *hsh, const char *s, vmvar *v);\n"
"INLINE vmhsh *hashmap_remove(vmctx *ctx, vmhsh *hsh, const char *s);\n"
"INLINE vmvar *hashmap_search(vmhsh *hsh, const char *s);\n"
"\n"
"INLINE void run_global(vmctx *ctx);\n"
"\n"
"/* Operator macros */\n"
"\n"
"/* Copy Variable */\n"
"\n"
"#define SET_I64(dst, v) (dst)->t = VAR_INT64; (dst)->i  = (v);\n"
"#define SET_DBL(dst, v) (dst)->t = VAR_DBL;   (dst)->d  = (v);\n"
"#define SET_BIG(dst, v) (dst)->t = VAR_BIG;   (dst)->bi = (v);\n"
"#define SET_STR(dst, v) (dst)->t = VAR_STR;   (dst)->s  = (v);\n"
"#define SET_FNC(dst, v) (dst)->t = VAR_FNC;   (dst)->f  = (v);\n"
"#define SET_OBJ(dst, v) (dst)->t = VAR_OBJ;   (dst)->a  = (v);\n"
"\n"
"#define COPY_VAR_TO(ctx, dst, src) { \\\n"
"    switch ((src)->t) { \\\n"
"    case VAR_INT64: \\\n"
"        (dst)->t = VAR_INT64; \\\n"
"        (dst)->i = (src)->i; \\\n"
"        break; \\\n"
"    case VAR_DBL: \\\n"
"        (dst)->t = VAR_DBL; \\\n"
"        (dst)->d = (src)->d; \\\n"
"        break; \\\n"
"    case VAR_BIG: \\\n"
"        (dst)->t = VAR_BIG; \\\n"
"        (dst)->bi = bi_copy(ctx, (src)->bi); \\\n"
"        break; \\\n"
"    case VAR_STR: \\\n"
"        (dst)->t = VAR_STR; \\\n"
"        /* TODO: copy */ \\\n"
"        break; \\\n"
"    case VAR_FNC: \\\n"
"        (dst)->t = VAR_FNC; \\\n"
"        (dst)->f = (src)->f; \\\n"
"        break; \\\n"
"    case VAR_OBJ: \\\n"
"        (dst)->t = VAR_OBJ; \\\n"
"        (dst)->a = (src)->a; \\\n"
"        break; \\\n"
"    default: \\\n"
"        /* Error */ \\\n"
"        (dst)->t = VAR_INT64; \\\n"
"        (dst)->i = 0; \\\n"
"        break; \\\n"
"    } \\\n"
"} \\\n"
"/**/\n"
"\n"
"#define SET_ARGVAR(idx, alc) { \\\n"
"    if (ac > idx) { \\\n"
"        vmvar *a##idx = arg_var(ctx, alc); \\\n"
"        COPY_VAR_TO(ctx, n##idx, a##idx); \\\n"
"    } else { \\\n"
"        init_var(n##idx); \\\n"
"    } \\\n"
"} \\\n"
"/**/\n"
"\n"
"/* ADD */\n"
"\n"
"#define OP_ADD_I_I(ctx, r, i0, i1) { \\\n"
"    if ((i0) >= 0) { \\\n"
"        if (((i1) <= 0) || ((i0) <= (INT64_MAX - (i1)))) { \\\n"
"            (r)->t = VAR_INT64; \\\n"
"            (r)->i = (i0) + (i1); \\\n"
"        } else { \\\n"
"            BigZ b2 = BzFromInteger(i1); \\\n"
"            BigZ bi = BzFromInteger(i0); \\\n"
"            (r)->t = VAR_BIG; \\\n"
"            (r)->bi = alcbgi_bigz(ctx, BzAdd(bi, b2)); \\\n"
"            BzFree(bi); \\\n"
"            BzFree(b2); \\\n"
"            bi_normalize(r); \\\n"
"        } \\\n"
"    } else if (((i1) >= 0) || ((i0) >= (INT64_MIN - (i1))))  { \\\n"
"        (r)->t = VAR_INT64; \\\n"
"        (r)->i = (i0) + (i1); \\\n"
"    } else { \\\n"
"        BigZ b2 = BzFromInteger(i1); \\\n"
"        BigZ bi = BzFromInteger(i0); \\\n"
"        (r)->t = VAR_BIG; \\\n"
"        (r)->bi = alcbgi_bigz(ctx, BzAdd(bi, b2)); \\\n"
"        BzFree(bi); \\\n"
"        BzFree(b2); \\\n"
"        bi_normalize(r); \\\n"
"    } \\\n"
"} \\\n"
"/**/\n"
"\n"
"#define OP_ADD_B_I(ctx, r, v0, i1) { \\\n"
"    BigZ bi = BzFromInteger(i1); \\\n"
"    (r)->t = VAR_BIG; \\\n"
"    (r)->bi = alcbgi_bigz(ctx, BzAdd((v0)->bi->b, bi)); \\\n"
"    BzFree(bi); \\\n"
"    bi_normalize(r); \\\n"
"} \\\n"
"/**/\n"
"\n"
"#define OP_ADD_I_B(ctx, r, i0, v1) { \\\n"
"    BigZ bi = BzFromInteger(i0); \\\n"
"    (r)->t = VAR_BIG; \\\n"
"    (r)->bi = alcbgi_bigz(ctx, BzAdd(bi, (v1)->bi->b)); \\\n"
"    BzFree(bi); \\\n"
"    bi_normalize(r); \\\n"
"} \\\n"
"/**/\n"
"\n"
"#define OP_ADD_V_I(ctx, r, v0, i1) { \\\n"
"    if ((v0)->t == VAR_INT64) { \\\n"
"        int64_t i0 = (v0)->i; \\\n"
"        OP_ADD_I_I(ctx, r, i0, i1) \\\n"
"    } else if ((v0)->t == VAR_BIG) { \\\n"
"        OP_ADD_B_I(ctx, r, v0, i1) \\\n"
"    } else { \\\n"
"        /* TODO */ \\\n"
"    } \\\n"
"} \\\n"
"/**/\n"
"\n"
"#define OP_ADD(ctx, r, v0, v1) { \\\n"
"    if ((v0)->t == VAR_INT64) { \\\n"
"        if ((v1)->t == VAR_INT64) { \\\n"
"            int64_t i0 = (v0)->i; \\\n"
"            int64_t i1 = (v1)->i; \\\n"
"            OP_ADD_I_I(ctx, r, i0, i1) \\\n"
"        } else if ((v1)->t == VAR_BIG) { \\\n"
"            int64_t i0 = (v0)->i; \\\n"
"            OP_ADD_I_B(ctx, r, i0, v1) \\\n"
"        } else { \\\n"
"            /* TODO */ \\\n"
"        } \\\n"
"    } else if ((v0)->t == VAR_BIG) { \\\n"
"        if ((v1)->t = VAR_INT64) { \\\n"
"            int64_t i1 = (v1)->i; \\\n"
"            OP_ADD_B_I(ctx, r, v0, i1) \\\n"
"        } else if ((v1)->t = VAR_BIG) { \\\n"
"            (r)->t = VAR_BIG; \\\n"
"            (r)->bi = alcbgi_bigz(ctx, BzAdd((v0)->bi->b, (v1)->bi->b)); \\\n"
"            bi_normalize(r); \\\n"
"        } else { \\\n"
"            /* TODO */ \\\n"
"        } \\\n"
"    } else { \\\n"
"        /* TODO */ \\\n"
"    } \\\n"
"} \\\n"
"/**/\n"
"\n"
"/* SUB */\n"
"\n"
"#define OP_SUB_I_I(ctx, r, i0, i1) { \\\n"
"    if ((i0) >= 0) { \\\n"
"        if (((i1) >= 0) || ((i0) <= (INT64_MAX + (i1)))) { \\\n"
"            (r)->t = VAR_INT64; \\\n"
"            (r)->i = (i0) - (i1); \\\n"
"        } else { \\\n"
"            BigZ b2 = BzFromInteger(i1); \\\n"
"            BigZ bi = BzFromInteger(i0); \\\n"
"            (r)->t = VAR_BIG; \\\n"
"            (r)->bi = alcbgi_bigz(ctx, BzSubtract(bi, b2)); \\\n"
"            BzFree(bi); \\\n"
"            BzFree(b2); \\\n"
"            bi_normalize(r); \\\n"
"        } \\\n"
"    } else if (((i1) <= 0) || ((i0) >= (INT64_MIN + (i1)))) { \\\n"
"        (r)->t = VAR_INT64; \\\n"
"        (r)->i = (i0) - (i1); \\\n"
"    } else { \\\n"
"        BigZ b2 = BzFromInteger(i1); \\\n"
"        BigZ bi = BzFromInteger(i0); \\\n"
"        (r)->t = VAR_BIG; \\\n"
"        (r)->bi = alcbgi_bigz(ctx, BzSubtract(bi, b2)); \\\n"
"        BzFree(bi); \\\n"
"        BzFree(b2); \\\n"
"        bi_normalize(r); \\\n"
"    } \\\n"
"} \\\n"
"/**/\n"
"\n"
"#define OP_SUB_B_I(ctx, r, v0, i1) { \\\n"
"    BigZ bi = BzFromInteger(i1); \\\n"
"    (r)->t = VAR_BIG; \\\n"
"    (r)->bi = alcbgi_bigz(ctx, BzSubtract((v0)->bi->b, bi)); \\\n"
"    BzFree(bi); \\\n"
"    bi_normalize(r); \\\n"
"} \\\n"
"/**/\n"
"\n"
"#define OP_SUB_I_B(ctx, r, i0, v1) { \\\n"
"    BigZ bi = BzFromInteger(i0); \\\n"
"    (r)->t = VAR_BIG; \\\n"
"    (r)->bi = alcbgi_bigz(ctx, BzSubtract(bi, (v1)->bi->b)); \\\n"
"    BzFree(bi); \\\n"
"    bi_normalize(r); \\\n"
"} \\\n"
"/**/\n"
"\n"
"#define OP_SUB_V_I(ctx, r, v0, i1) { \\\n"
"    if ((v0)->t == VAR_INT64) { \\\n"
"        int64_t i0 = (v0)->i; \\\n"
"        OP_SUB_I_I(ctx, r, i0, i1) \\\n"
"    } else if ((v0)->t == VAR_BIG) { \\\n"
"        OP_SUB_B_I(ctx, r, v0, i1) \\\n"
"    } else { \\\n"
"        /* TODO */ \\\n"
"    } \\\n"
"} \\\n"
"/**/\n"
"\n"
"#define OP_SUB(ctx, r, v0, v1) { \\\n"
"    if ((v0)->t == VAR_INT64) { \\\n"
"        if ((v1)->t == VAR_INT64) { \\\n"
"            int64_t i0 = (v0)->i; \\\n"
"            int64_t i1 = (v1)->i; \\\n"
"            OP_SUB_I_I(ctx, r, i0, i1) \\\n"
"        } else if ((v1)->t == VAR_BIG) { \\\n"
"            int64_t i0 = (v0)->i; \\\n"
"            OP_SUB_I_B(ctx, r, i0, v1) \\\n"
"        } else { \\\n"
"            /* TODO */ \\\n"
"        } \\\n"
"    } else if ((v0)->t == VAR_BIG) { \\\n"
"        if ((v1)->t = VAR_INT64) { \\\n"
"            int64_t i1 = (v1)->i; \\\n"
"            OP_SUB_B_I(ctx, r, v0, i1) \\\n"
"        } else if ((v1)->t = VAR_BIG) { \\\n"
"            (r)->t = VAR_BIG; \\\n"
"            (r)->bi = alcbgi_bigz(ctx, BzSubtract((v0)->bi->b, (v1)->bi->b)); \\\n"
"        } else { \\\n"
"            /* TODO */ \\\n"
"        } \\\n"
"    } else { \\\n"
"        /* TODO */ \\\n"
"    } \\\n"
"} \\\n"
"/**/\n"
"\n"
"/* Conditional Jump */\n"
"\n"
"#define OP_JMP_IF_FALSE(r, label) { \\\n"
"    if ((r)->t == VAR_INT64) { \\\n"
"        if ((r)->i == 0) goto label; \\\n"
"    } else { \\\n"
"        /* TODO */ \\\n"
"    } \\\n"
"} \\\n"
"/**/\n"
"\n"
"/* LT */\n"
"\n"
"#define OP_LT_I_I(ctx, r, i0, i1) { \\\n"
"    (r)->t = VAR_INT64; \\\n"
"    (r)->i = (i0) < (i1); \\\n"
"} \\\n"
"/**/\n"
"\n"
"#define OP_LT_B_I(ctx, r, v0, i1) { \\\n"
"    BigZ b1 = BzFromInteger(i1); \\\n"
"    BzCmp c = BzCompare((v0)->bi->b, b1); \\\n"
"    BzFree(b1); \\\n"
"    (r)->t = VAR_INT64; \\\n"
"    (r)->i = (c == BZ_LT); \\\n"
"} \\\n"
"/**/\n"
"\n"
"#define OP_LT_I_B(ctx, r, i0, v1) { \\\n"
"    BigZ b0 = BzFromInteger(i0); \\\n"
"    BzCmp c = BzCompare(b0, (v1)->bi->b); \\\n"
"    BzFree(b0); \\\n"
"    (r)->t = VAR_INT64; \\\n"
"    (r)->i = (c == BZ_LT); \\\n"
"} \\\n"
"/**/\n"
"\n"
"#define OP_LT_V_I(ctx, r, v0, i1) { \\\n"
"    if ((v0)->t == VAR_INT64) { \\\n"
"        OP_LT_I_I(ctx, r, (v0)->i, i1) \\\n"
"    } else if ((v0)->t == VAR_BIG) { \\\n"
"        OP_LT_B_I(ctx, r, v0, i1) \\\n"
"    } else { \\\n"
"        /* TODO */ \\\n"
"    } \\\n"
"} \\\n"
"/**/\n"
"\n"
"#define OP_LT(ctx, r, v0, v1) { \\\n"
"    if ((v0)->t == VAR_INT64) { \\\n"
"        if ((v1)->t == VAR_INT64) { \\\n"
"            OP_LT_I_I(ctx, r, (v0)->i, (v1)->i); \\\n"
"        } else if ((v1)->t = VAR_BIG) { \\\n"
"            int64_t i0 = (v0)->i; \\\n"
"            OP_LT_I_B(ctx, r, i0, v1) \\\n"
"        } else { \\\n"
"            /* TODO */ \\\n"
"        } \\\n"
"    } else if ((v0)->t == VAR_BIG) { \\\n"
"        if ((v1)->t = VAR_INT64) { \\\n"
"            int64_t i1 = (v1)->i; \\\n"
"            OP_LT_B_I(ctx, r, v0, i1) \\\n"
"        } else if ((v1)->t = VAR_BIG) { \\\n"
"            BzCmp c = BzCompare((v0)->bi->b, (v1)->bi->b); \\\n"
"            (r)->t = VAR_INT64; \\\n"
"            (r)->i = (c == BZ_LT); \\\n"
"        } else { \\\n"
"            /* TODO */ \\\n"
"        } \\\n"
"    } else { \\\n"
"            /* TODO */ \\\n"
"    } \\\n"
"} \\\n"
"/**/\n"
"\n"
"#endif /* KILITE_TEMPLATE_HEADER_H */\n"
"\n";

const char *vmheader(void)
{
    return header;
}

